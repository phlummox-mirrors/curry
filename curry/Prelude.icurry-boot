interface Prelude where {
infixr 0 $;
infixr 0 $!;
infixr 0 $!!;
infixr 0 $#;
infixr 0 $##;
infixr 0 &;
infixr 3 &&;
infixr 0 &>;
infixl 7 *;
infixl 7 *.;
infixl 6 +;
infixr 5 ++;
infixl 6 +.;
infixl 6 -;
infixl 6 -.;
infixr 9 .;
infixl 7 /.;
infix 4 /=;
infix 4 <;
infix 4 <=;
infix 4 =/=;
infix 4 =:=;
infix 4 ==;
infix 4 >;
infix 4 >=;
infixl 1 >>;
infixl 1 >>=;
infixr 0 ?;
infixl 7 `div`;
infix 4 `elem`;
infixl 7 `mod`;
infix 4 `notElem`;
infixl 7 `quot`;
infixl 7 `rem`;
infixr 0 `seq`;
infixr 2 ||;
data Bool = False | True;
data Char;
data Either a b = Left a | Right b;
type FilePath = [Char];
data Float;
data IO a;
type IOError = [Char];
data Int;
data Maybe a = Nothing | Just a;
data Ordering = LT | EQ | GT;
type ShowS = [Char] -> [Char];
type String = [Char];
data Success;
(!!) :: [a] -> Int -> a;
($) :: (a -> b) -> a -> b;
($!) :: (a -> b) -> a -> b;
($!!) :: (a -> b) -> a -> b;
($#) :: (a -> b) -> a -> b;
($##) :: (a -> b) -> a -> b;
(&) :: Success -> Success -> Success;
(&&) :: Bool -> Bool -> Bool;
(&>) :: Success -> a -> a;
(*) :: Int -> Int -> Int;
(*.) :: Float -> Float -> Float;
(+) :: Int -> Int -> Int;
(++) :: [a] -> [a] -> [a];
(+.) :: Float -> Float -> Float;
(-) :: Int -> Int -> Int;
(-.) :: Float -> Float -> Float;
(.) :: (a -> b) -> (c -> a) -> c -> b;
(/.) :: Float -> Float -> Float;
(/=) :: a -> a -> Bool;
(<) :: a -> a -> Bool;
(<=) :: a -> a -> Bool;
(=/=) :: a -> a -> Success;
(=:=) :: a -> a -> Success;
(==) :: a -> a -> Bool;
(>) :: a -> a -> Bool;
(>=) :: a -> a -> Bool;
(>>) :: {-# ARITY 3 #-} IO a -> IO b -> IO b;
(>>=) :: {-# ARITY 3 #-} IO a -> (a -> IO b) -> IO b;
(?) :: a -> a -> a;
all :: (a -> Bool) -> [a] -> Bool;
and :: [Bool] -> Bool;
any :: (a -> Bool) -> [a] -> Bool;
appendFile :: [Char] -> [Char] -> IO ();
best :: (a -> Success) -> (a -> a -> Bool) -> [a -> Success];
break :: (a -> Bool) -> [a] -> ([a], [a]);
browse :: (a -> Success) -> IO ();
browseList :: [a -> Success] -> IO ();
catch :: {-# ARITY 3 #-} IO a -> ([Char] -> IO a) -> IO a;
chr :: Int -> Char;
compare :: a -> a -> Ordering;
concat :: [[a]] -> [a];
concatMap :: (a -> [b]) -> [a] -> [b];
const :: a -> b -> a;
curry :: ((a, b) -> c) -> a -> b -> c;
div :: Int -> Int -> Int;
doSolve :: Success -> IO ();
done :: {-# ARITY 1 #-} IO ();
drop :: Int -> [a] -> [a];
dropWhile :: (a -> Bool) -> [a] -> [a];
either :: (a -> b) -> (c -> b) -> Either a c -> b;
elem :: a -> [a] -> Bool;
ensureGround :: a -> a;
ensureNotFree :: a -> a;
ensureSpine :: [a] -> [a];
enumFrom :: Int -> [Int];
enumFromThen :: Int -> Int -> [Int];
enumFromThenTo :: Int -> Int -> Int -> [Int];
enumFromTo :: Int -> Int -> [Int];
error :: [Char] -> a;
failed :: a;
filter :: (a -> Bool) -> [a] -> [a];
findall :: (a -> Success) -> [a];
findfirst :: (a -> Success) -> a;
flip :: (a -> b -> c) -> b -> a -> c;
floatFromInt :: Int -> Float;
foldl :: (a -> b -> a) -> a -> [b] -> a;
foldl1 :: (a -> a -> a) -> [a] -> a;
foldr :: (a -> b -> b) -> b -> [a] -> b;
foldr1 :: (a -> a -> a) -> [a] -> a;
fst :: (a, b) -> a;
getChar :: IO Char;
getContents :: IO [Char];
getLine :: IO [Char];
head :: [a] -> a;
id :: a -> a;
if_then_else :: Bool -> a -> a -> a;
inject :: (a -> Success) -> (a -> Success) -> a -> Success;
interact :: ([Char] -> [Char]) -> IO ();
ioError :: {-# ARITY 2 #-} [Char] -> IO a;
iterate :: (a -> a) -> a -> [a];
length :: [a] -> Int;
lines :: [Char] -> [[Char]];
lookup :: a -> [(a, b)] -> Maybe b;
map :: (a -> b) -> [a] -> [b];
mapIO :: (a -> IO b) -> [a] -> IO [b];
mapIO_ :: (a -> IO b) -> [a] -> IO ();
max :: a -> a -> a;
maybe :: a -> (b -> a) -> Maybe b -> a;
min :: a -> a -> a;
mod :: Int -> Int -> Int;
negate :: Int -> Int;
negateFloat :: Float -> Float;
not :: Bool -> Bool;
notElem :: a -> [a] -> Bool;
null :: [a] -> Bool;
once :: {-# ARITY 1 #-} (a -> Success) -> a -> Success;
or :: [Bool] -> Bool;
ord :: Char -> Int;
otherwise :: Bool;
print :: a -> IO ();
putChar :: {-# ARITY 0 #-} Char -> IO ();
putStr :: {-# ARITY 0 #-} [Char] -> IO ();
putStrLn :: {-# ARITY 0 #-} [Char] -> IO ();
quot :: Int -> Int -> Int;
readFile :: [Char] -> IO [Char];
rem :: Int -> Int -> Int;
repeat :: a -> [a];
replicate :: Int -> a -> [a];
return :: {-# ARITY 2 #-} a -> IO a;
reverse :: [a] -> [a];
roundFloat :: Float -> Int;
seq :: a -> b -> b;
sequenceIO :: [IO a] -> IO [a];
sequenceIO_ :: [IO a] -> IO ();
show :: a -> [Char];
showChar :: Char -> [Char] -> [Char];
showList :: {-# ARITY 1 #-} [a] -> [Char] -> [Char];
showParen :: {-# ARITY 2 #-} Bool -> ([Char] -> [Char]) ->
			     [Char] -> [Char];
showString :: [Char] -> [Char] -> [Char];
shows :: a -> [Char] -> [Char];
snd :: (a, b) -> b;
solveAll :: (a -> Success) -> [a -> Success];
span :: (a -> Bool) -> [a] -> ([a], [a]);
splitAt :: Int -> [a] -> ([a], [a]);
success :: Success;
tail :: [a] -> [a];
take :: Int -> [a] -> [a];
takeWhile :: (a -> Bool) -> [a] -> [a];
truncateFloat :: Float -> Int;
try :: (a -> Success) -> [a -> Success];
uncurry :: (a -> b -> c) -> (a, b) -> c;
undefined :: a;
unknown :: a;
unlines :: [[Char]] -> [Char];
unpack :: (a -> Success) -> a;
until :: (a -> Bool) -> (a -> a) -> a -> a;
unwords :: [[Char]] -> [Char];
unzip :: [(a, b)] -> ([a], [b]);
unzip3 :: [(a, b, c)] -> ([a], [b], [c]);
words :: [Char] -> [[Char]];
writeFile :: [Char] -> [Char] -> IO ();
zip :: [a] -> [b] -> [(a, b)];
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)];
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c];
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d];
(||) :: Bool -> Bool -> Bool
}
