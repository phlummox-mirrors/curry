interface Prelude where {
infixr 5 :;
infixr 0 $;
infixr 0 $!;
infixr 0 $!!;
infixr 0 $#;
infixr 0 $##;
infixr 0 &;
infixr 3 &&;
infixr 0 &>;
infixl 7 *;
infixl 7 *.;
infixl 6 +;
infixr 5 ++;
infixl 6 +.;
infixl 6 -;
infixl 6 -.;
infixr 9 .;
infixl 7 /.;
infix 4 /=;
infix 4 <;
infix 4 <=;
infix 4 =/=;
infix 4 =:<=;
infix 4 =:=;
infix 4 ==;
infix 4 ==<=;
infix 4 >;
infix 4 >=;
infixl 1 >>;
infixl 1 >>=;
infixr 0 ?;
infixl 8 ^;
infixl 8 ^.;
infixl 8 ^^.;
infixl 7 `div`;
infix 4 `elem`;
infixl 7 `mod`;
infix 4 `notElem`;
infixl 7 `quot`;
infixl 7 `rem`;
infixr 0 `seq`;
infixr 2 ||;
data () = ();
data (,) a b = (,) a b;
data (,,) a b c = (,,) a b c;
data (,,,) a b c d = (,,,) a b c d;
data (,,,,) a b c d e = (,,,,) a b c d e;
data (,,,,,) a b c d e f = (,,,,,) a b c d e f;
data (,,,,,,) a b c d e f g = (,,,,,,) a b c d e f g;
data (,,,,,,,) a b c d e f g h = (,,,,,,,) a b c d e f g h;
data (,,,,,,,,) a b c d e f g h i = (,,,,,,,,) a b c d e f g h i;
data (,,,,,,,,,) a b c d e f g h i j
  = (,,,,,,,,,) a b c d e f g h i j;
data (,,,,,,,,,,) a b c d e f g h i j k
  = (,,,,,,,,,,) a b c d e f g h i j k;
data (,,,,,,,,,,,) a b c d e f g h i j k l
  = (,,,,,,,,,,,) a b c d e f g h i j k l;
data (,,,,,,,,,,,,) a b c d e f g h i j k l m
  = (,,,,,,,,,,,,) a b c d e f g h i j k l m;
data (,,,,,,,,,,,,,) a b c d e f g h i j k l m n
  = (,,,,,,,,,,,,,) a b c d e f g h i j k l m n;
data (,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o
  = (,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o;
data (,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p
  = (,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p;
data (,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q
  = (,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q;
data (,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r
  = (,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r;
data (,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s
  = (,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s;
data (,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t
  = (,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t;
data (,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u
  = (,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u;
data (,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v
  = (,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u
			    v;
data (,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w
  = (,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t
			     u v w;
data (,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x
  = (,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t
			      u v w x;
data (,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y
  = (,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s
			       t u v w x y;
data (,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z
  = (,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s
				t u v w x y z;
data (,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1
  = (,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r
				 s t u v w x y z a1;
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1
  = (,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r
				  s t u v w x y z a1 b1;
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1
  = (,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q
				   r s t u v w x y z a1 b1 c1;
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1
  = (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q
				    r s t u v w x y z a1 b1 c1 d1;
data Bool = False | True;
data Char;
data Either a b = Left a | Right b;
type FilePath = [Char];
data Float;
data IO a;
type IOError = [Char];
data Int;
data Maybe a = Nothing | Just a;
data Ordering = LT | EQ | GT;
type ShowS = [Char] -> [Char];
type String = [Char];
type Success = Bool;
data [] a = [] | (:) a [a];
(!!) :: [a] -> Int -> a;
($) :: (a -> b) -> a -> b;
($!) :: (a -> b) -> a -> b;
($!!) :: (a -> b) -> a -> b;
($#) :: (a -> b) -> a -> b;
($##) :: (a -> b) -> a -> b;
(&) :: Bool -> Bool -> Bool;
(&&) :: Bool -> Bool -> Bool;
(&>) :: Bool -> a -> a;
(*) :: Int -> Int -> Int;
(*.) :: Float -> Float -> Float;
(+) :: Int -> Int -> Int;
(++) :: [a] -> [a] -> [a];
(+.) :: Float -> Float -> Float;
(-) :: Int -> Int -> Int;
(-.) :: Float -> Float -> Float;
(.) :: (a -> b) -> (c -> a) -> c -> b;
(/.) :: Float -> Float -> Float;
(/=) :: a -> a -> Bool;
(<) :: a -> a -> Bool;
(<=) :: a -> a -> Bool;
(=/=) :: a -> a -> Bool;
(=:<=) :: a -> a -> Bool;
(=:=) :: a -> a -> Bool;
(==) :: a -> a -> Bool;
(==<=) :: a -> a -> Bool;
(>) :: a -> a -> Bool;
(>=) :: a -> a -> Bool;
(>>) :: {-# ARITY 3 #-} IO a -> IO b -> IO b;
(>>=) :: {-# ARITY 3 #-} IO a -> (a -> IO b) -> IO b;
(?) :: a -> a -> a;
(^) :: Int -> Int -> Int;
(^.) :: Float -> Int -> Float;
(^^.) :: Float -> Int -> Float;
abs :: Int -> Int;
absFloat :: Float -> Float;
all :: (a -> Bool) -> [a] -> Bool;
and :: [Bool] -> Bool;
any :: (a -> Bool) -> [a] -> Bool;
appendFile :: [Char] -> [Char] -> IO ();
best :: (a -> Bool) -> (a -> a -> Bool) -> [a -> Bool];
break :: (a -> Bool) -> [a] -> ([a], [a]);
browse :: (a -> Bool) -> IO ();
browseList :: [a -> Bool] -> IO ();
catch :: {-# ARITY 3 #-} IO a -> ([Char] -> IO a) -> IO a;
chr :: Int -> Char;
compare :: a -> a -> Ordering;
concat :: [[a]] -> [a];
concatMap :: (a -> [b]) -> [a] -> [b];
const :: a -> b -> a;
curry :: ((a, b) -> c) -> a -> b -> c;
div :: Int -> Int -> Int;
doSolve :: Bool -> IO ();
done :: {-# ARITY 1 #-} IO ();
drop :: Int -> [a] -> [a];
dropWhile :: (a -> Bool) -> [a] -> [a];
either :: (a -> b) -> (c -> b) -> Either a c -> b;
elem :: a -> [a] -> Bool;
ensureGround :: a -> a;
ensureNotFree :: a -> a;
ensureSpine :: [a] -> [a];
enumFrom :: Int -> [Int];
enumFromThen :: Int -> Int -> [Int];
enumFromThenTo :: Int -> Int -> Int -> [Int];
enumFromTo :: Int -> Int -> [Int];
error :: [Char] -> a;
even :: Int -> Bool;
fail :: {-# ARITY 2 #-} [Char] -> IO a;
failed :: a;
filter :: (a -> Bool) -> [a] -> [a];
findall :: (a -> Bool) -> [a];
findfirst :: (a -> Bool) -> a;
flip :: (a -> b -> c) -> b -> a -> c;
floatFromInt :: Int -> Float;
foldl :: (a -> b -> a) -> a -> [b] -> a;
foldl1 :: (a -> a -> a) -> [a] -> a;
foldr :: (a -> b -> b) -> b -> [a] -> b;
foldr1 :: (a -> a -> a) -> [a] -> a;
fst :: (a, b) -> a;
gcd :: Int -> Int -> Int;
getChar :: IO Char;
getContents :: IO [Char];
getLine :: IO [Char];
head :: [a] -> a;
id :: a -> a;
if_then_else :: Bool -> a -> a -> a;
inject :: (a -> Bool) -> (a -> Bool) -> a -> Bool;
interact :: ([Char] -> [Char]) -> IO ();
ioError :: {-# ARITY 2 #-} [Char] -> IO a;
iterate :: (a -> a) -> a -> [a];
lcm :: Int -> Int -> Int;
length :: [a] -> Int;
lines :: [Char] -> [[Char]];
lookup :: a -> [(a, b)] -> Maybe b;
map :: (a -> b) -> [a] -> [b];
mapIO :: (a -> IO b) -> [a] -> IO [b];
mapIO_ :: (a -> IO b) -> [a] -> IO ();
max :: a -> a -> a;
maybe :: a -> (b -> a) -> Maybe b -> a;
min :: a -> a -> a;
mod :: Int -> Int -> Int;
negate :: Int -> Int;
negateFloat :: Float -> Float;
not :: Bool -> Bool;
notElem :: a -> [a] -> Bool;
null :: [a] -> Bool;
odd :: Int -> Bool;
once :: {-# ARITY 1 #-} (a -> Bool) -> a -> Bool;
or :: [Bool] -> Bool;
ord :: Char -> Int;
otherwise :: Bool;
print :: a -> IO ();
putChar :: {-# ARITY 0 #-} Char -> IO ();
putStr :: {-# ARITY 0 #-} [Char] -> IO ();
putStrLn :: {-# ARITY 0 #-} [Char] -> IO ();
quot :: Int -> Int -> Int;
readFile :: [Char] -> IO [Char];
rem :: Int -> Int -> Int;
repeat :: a -> [a];
replicate :: Int -> a -> [a];
return :: {-# ARITY 2 #-} a -> IO a;
reverse :: [a] -> [a];
roundFloat :: Float -> Int;
seq :: a -> b -> b;
sequenceIO :: [IO a] -> IO [a];
sequenceIO_ :: [IO a] -> IO ();
show :: a -> [Char];
showChar :: Char -> [Char] -> [Char];
showList :: {-# ARITY 1 #-} [a] -> [Char] -> [Char];
showParen :: {-# ARITY 2 #-} Bool -> ([Char] -> [Char]) ->
			     [Char] -> [Char];
showString :: [Char] -> [Char] -> [Char];
shows :: a -> [Char] -> [Char];
signum :: Int -> Int;
signumFloat :: Float -> Float;
snd :: (a, b) -> b;
solve :: Bool -> Bool;
solveAll :: (a -> Bool) -> [a -> Bool];
span :: (a -> Bool) -> [a] -> ([a], [a]);
splitAt :: Int -> [a] -> ([a], [a]);
subtract :: Int -> Int -> Int;
subtractFloat :: Float -> Float -> Float;
success :: Bool;
tail :: [a] -> [a];
take :: Int -> [a] -> [a];
takeWhile :: (a -> Bool) -> [a] -> [a];
truncateFloat :: Float -> Int;
try :: (a -> Bool) -> [a -> Bool];
uncurry :: (a -> b -> c) -> (a, b) -> c;
undefined :: a;
unknown :: a;
unlines :: [[Char]] -> [Char];
unpack :: (a -> Bool) -> a;
until :: (a -> Bool) -> (a -> a) -> a -> a;
unwords :: [[Char]] -> [Char];
unzip :: [(a, b)] -> ([a], [b]);
unzip3 :: [(a, b, c)] -> ([a], [b], [c]);
words :: [Char] -> [[Char]];
writeFile :: [Char] -> [Char] -> IO ();
zip :: [a] -> [b] -> [(a, b)];
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)];
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c];
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d];
(||) :: Bool -> Bool -> Bool
}
