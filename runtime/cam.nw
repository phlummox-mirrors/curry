% -*- noweb-code-mode: c-mode -*-
% $Id: cam.nw 1864 2006-02-28 15:58:21Z wlux $
%
% Copyright (c) 2001-2005, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{Abstract Machine Instruction Macros}
The header file [[cam.h]] defines a few useful macros for writing
external functions.

@
The [[RETURN]] and [[ENTER]] macros return a value on the top of the
stack to the caller of the current function. [[RETURN]] must be used
only if the value is known to be in head normal form. Otherwise the
[[ENTER]] macro must be used which starts the evaluation of the node
if it is not in head normal form with a tail call to the evaluation
code.

<<cam.h>>=
#define RETURN(_res) { \
    Label ret_ip = (Label)sp[0]; \
    sp[0] = (_res); \
    GOTO(ret_ip); \
}

#define ENTER(_node) { \
    if ( is_boxed(_node) ) { \
	CHECK_STACK1(); \
	*--sp = (_node); \
	GOTO((_node)->info->eval); \
    } \
    RETURN(_node); \
}

@
The [[FAIL]] macro invokes the current failure handler.

<<cam.h>>=
#define FAIL() GOTO(nondet_handlers->fail)

@
The following macros implement evaluation of the node on the top of
the stack. All macros except [[EVAL_FLEX_POLY]] also suspend the
current thread until the node is not an unbound variable.
[[EVAL_RIGID_INT]], [[EVAL_FLEX_POLY]], and [[EVAL_RIGID_POLY]]
carefully check for unboxed values while the other macros assume that
the node on the top of the stack is always boxed. The argument of all
macros is the label where execution continues after the node has been
evaluated or after resuming the current thread. In general this is the
entry point of the function that uses the [[EVAL]] macro.

<<cam.h>>=
#define EVAL_RIGID(l) \
for (;;) { \
    switch ( sp[0]->info->tag ) { \
    case INDIR_TAG: sp[0] = sp[0]->n.node; continue; \
    case FAPP_TAG: case SUSPEND_TAG: case QUEUEME_TAG: \
	CHECK_STACK1(); sp -= 1; sp[0] = sp[1]; sp[1] = (Node *)(l); \
	GOTO(sp[0]->info->eval); \
    case VARIABLE_TAG: \
	CHECK_STACK1(); sp -= 1; sp[0] = sp[1]; sp[1] = (Node *)(l); \
	GOTO(sync_var); \
    default: break; \
    } \
    break; \
}

#define EVAL_RIGID_CHAR(l) \
for (;;) { \
    switch ( sp[0]->info->tag ) { \
    case INDIR_TAG: sp[0] = sp[0]->n.node; continue; \
    case FAPP_TAG: case SUSPEND_TAG: case QUEUEME_TAG: \
	CHECK_STACK1(); sp -= 1; sp[0] = sp[1]; sp[1] = (Node *)(l); \
	GOTO(sp[0]->info->eval); \
    case VARIABLE_TAG: \
	CHECK_STACK1(); sp -= 1; sp[0] = sp[1]; sp[1] = (Node *)(l); \
	GOTO(sync_var); \
    case CHAR_TAG: break; \
    default: invalid_arg(#l, sp[0]->info->tag); \
    } \
    break; \
}

#define EVAL_RIGID_INT(l) \
for (;;) { \
    if ( is_boxed(sp[0]) ) \
	switch ( sp[0]->info->tag ) { \
	case INDIR_TAG: sp[0] = sp[0]->n.node; continue; \
	case FAPP_TAG: case SUSPEND_TAG: case QUEUEME_TAG: \
	    CHECK_STACK1(); sp -= 1; sp[0] = sp[1]; sp[1] = (Node *)(l); \
	    GOTO(sp[0]->info->eval); \
	case VARIABLE_TAG: \
	    CHECK_STACK1(); sp -= 1; sp[0] = sp[1]; sp[1] = (Node *)(l); \
	    GOTO(sync_var); \
	case INT_TAG: break; \
	default: invalid_arg(#l, sp[0]->info->tag); \
	} \
    break; \
}

#define EVAL_RIGID_FLOAT(l) \
for (;;) { \
    switch ( sp[0]->info->tag ) { \
    case INDIR_TAG: sp[0] = sp[0]->n.node; continue; \
    case FAPP_TAG: case SUSPEND_TAG: case QUEUEME_TAG: \
	CHECK_STACK1(); sp -= 1; sp[0] = sp[1]; sp[1] = (Node *)(l); \
	GOTO(sp[0]->info->eval); \
    case VARIABLE_TAG: \
	CHECK_STACK1(); sp -= 1; sp[0] = sp[1]; sp[1] = (Node *)(l); \
	GOTO(sync_var); \
    case FLOAT_TAG: break; \
    default: invalid_arg(#l, sp[0]->info->tag); \
    } \
    break; \
}

#define EVAL_RIGID_PTR(l) \
for (;;) { \
    switch ( sp[0]->info->tag ) { \
    case INDIR_TAG: sp[0] = sp[0]->n.node; continue; \
    case FAPP_TAG: case SUSPEND_TAG: case QUEUEME_TAG: \
	CHECK_STACK1(); sp -= 1; sp[0] = sp[1]; sp[1] = (Node *)(l); \
	GOTO(sp[0]->info->eval); \
    case VARIABLE_TAG: \
	CHECK_STACK1(); sp -= 1; sp[0] = sp[1]; sp[1] = (Node *)(l); \
	GOTO(sync_var); \
    case PTR_TAG: break; \
    default: invalid_arg(#l, sp[0]->info->tag); \
    } \
    break; \
}

#define EVAL_RIGID_FOREIGN_PTR(l) \
for (;;) { \
    switch ( sp[0]->info->tag ) { \
    case INDIR_TAG: sp[0] = sp[0]->n.node; continue; \
    case FAPP_TAG: case SUSPEND_TAG: case QUEUEME_TAG: \
	CHECK_STACK1(); sp -= 1; sp[0] = sp[1]; sp[1] = (Node *)(l); \
	GOTO(sp[0]->info->eval); \
    case VARIABLE_TAG: \
	CHECK_STACK1(); sp -= 1; sp[0] = sp[1]; sp[1] = (Node *)(l); \
	GOTO(sync_var); \
    case FOREIGN_PTR_TAG: break; \
    default: invalid_arg(#l, sp[0]->info->tag); \
    } \
    break; \
}

#define EVAL_RIGID_VECTOR(l) \
for (;;) { \
    switch ( sp[0]->info->tag ) { \
    case INDIR_TAG: sp[0] = sp[0]->n.node; continue; \
    case FAPP_TAG: case SUSPEND_TAG: case QUEUEME_TAG: \
	CHECK_STACK1(); sp -= 1; sp[0] = sp[1]; sp[1] = (Node *)(l); \
	GOTO(sp[0]->info->eval); \
    case VARIABLE_TAG: \
	CHECK_STACK1(); sp -= 1; sp[0] = sp[1]; sp[1] = (Node *)(l); \
	GOTO(sync_var); \
    case VECTOR_TAG: break; \
    default: invalid_arg(#l, sp[0]->info->tag); \
    } \
    break; \
}

#define EVAL_RIGID_ABSTRACT(l) \
for (;;) { \
    switch ( sp[0]->info->tag ) { \
    case INDIR_TAG: sp[0] = sp[0]->n.node; continue; \
    case FAPP_TAG: case SUSPEND_TAG: case QUEUEME_TAG: \
	CHECK_STACK1(); sp -= 1; sp[0] = sp[1]; sp[1] = (Node *)(l); \
	GOTO(sp[0]->info->eval); \
    case VARIABLE_TAG: \
	CHECK_STACK1(); sp -= 1; sp[0] = sp[1]; sp[1] = (Node *)(l); \
	GOTO(sync_var); \
    case ABSTRACT_TAG: break; \
    default: invalid_arg(#l, sp[0]->info->tag); \
    } \
    break; \
}

#define EVAL_FLEX_POLY(l) \
for (;;) { \
    if ( is_boxed(sp[0]) ) \
	switch ( sp[0]->info->tag ) { \
	case INDIR_TAG: sp[0] = sp[0]->n.node; continue; \
	case FAPP_TAG: case SUSPEND_TAG: case QUEUEME_TAG: \
	    CHECK_STACK1(); sp -= 1; sp[0] = sp[1]; sp[1] = (Node *)(l); \
	    GOTO(sp[0]->info->eval); \
	default: break; \
	} \
    break; \
}

#define EVAL_RIGID_POLY(l) \
for (;;) { \
    if ( is_boxed(sp[0]) ) \
	switch ( sp[0]->info->tag ) { \
	case INDIR_TAG: sp[0] = sp[0]->n.node; continue; \
	case FAPP_TAG: case SUSPEND_TAG: case QUEUEME_TAG: \
	    CHECK_STACK1(); sp -= 1; sp[0] = sp[1]; sp[1] = (Node *)(l); \
	    GOTO(sp[0]->info->eval); \
	case VARIABLE_TAG: \
	    CHECK_STACK1(); sp -= 1; sp[0] = sp[1]; sp[1] = (Node *)(l); \
	    GOTO(sync_var); \
	default: break; \
	} \
    break; \
}
