% -*- noweb-code-mode: c-mode -*-
% $Id: constraints.nw 1744 2005-08-23 16:17:12Z wlux $
%
% Copyright (c) 2002-2005, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{Basic Constraints}
This file implements two basic constraint functions, viz. the trivial
constraint \texttt{success}, which is always satisfied, and the
concurrent conjunction of two constraints \texttt{\&}. The equality
constraint \texttt{=:=} is defined in section~\ref{sec:unification}.

<<constraints.c>>=
#include "config.h"
#include <stdio.h>
#include <stdlib.h>
#include "debug.h"
#include "run.h"
#include "heap.h"
#include "stack.h"
#include "eval.h"
#include "threads.h"
#include "spaces.h"
#include "cam.h"
#include "trace.h"

DECLARE_ENTRYPOINT(__success);

FUNCTION(__success)
{
    EXPORT_LABEL(__success)
 ENTRY_LABEL(__success)
    RETURN(Success);
}

@
The code for the parallel conjunction tries to avoid creating a
new thread whenever this is possible. The only case where a new thread
must be started is when both arguments are (suspended)
applications. In this case, the evaluation of the first argument is
started on a new thread. In order to synchronize the current thread
and its new child, at least one of the applications must be a
suspension. A new suspension node is created if
necessary. Otherwise, if there is one argument that is not in normal
form, its evaluation will be started. Finally, for queue-me closures
and in the case of two variables, the current thread will be
suspended. Note that the concurrent conjunction may return an unbound
variable to the caller. The caller is responsible for suspending the
computation until this variable is bound.

<<constraints.c>>=
DECLARE_ENTRYPOINT(___38_);
DECLARE_LABEL(___38__1);
DECLARE_LABEL(___38__2);

FUNCTION(___38_)
{
    Node *c1, *c2, *aux;

    EXPORT_LABEL(___38_)
 ENTRY_LABEL(___38_)

    for ( c1 = sp[0]; node_tag(c1) == INDIR_TAG; c1 = c1->n.node )
	;
    for ( c2 = sp[1]; node_tag(c2) == INDIR_TAG; c2 = c2->n.node )
	;

    switch ( node_tag(c1) )
    {
    case FAPP_TAG:
	switch ( node_tag(c2) )
	{
	case FAPP_TAG:
	    sp[0] = c1;
	    sp[1] = c2;
	    CHECK_HEAP(queueMe_node_size);
	    aux	       = (Node *)hp;
	    aux->info  = queueMe_info_table;
	    aux->q.spc = ss;
	    aux->q.wq  = 0;
	    hp	      += queueMe_node_size;
	    CHECK_STACK(4);
	    sp	 -= 4;
	    sp[0] = sp[4];
	    sp[1] = (Node *)update;
	    sp[2] = aux;
	    sp[3] = (Node *)___38_;
	    sp[4] = aux;
	    start_thread(4);
	    GOTO(sp[0]->info->eval);
	case SUSPEND_TAG:
	    aux = c1;
	    c1	= c2;
	    c2	= aux;
	    break;
	}
	/* FALL THROUGH!!! */
    case SUSPEND_TAG:
	switch ( node_tag(c2) )
	{
	case FAPP_TAG:
	case SUSPEND_TAG:
	    CHECK_STACK(2);
	    sp	 -= 2;
	    sp[0] = c1;
	    sp[1] = (Node *)___38_;
	    sp[2] = c1;
	    sp[3] = c2;
	    start_thread(2);
	    GOTO(sp[0]->info->eval);
	case QUEUEME_TAG:
	case VARIABLE_TAG:
	    CHECK_STACK1();
	    sp	 -= 1;
	    sp[0] = c1;
	    sp[1] = (Node *)___38__1;
	    sp[2] = c2;
	    GOTO(c1->info->eval);
	case SUCCESS_TAG:
	    *++sp = c1;
	    GOTO(c1->info->eval);
	}
	break;
    case QUEUEME_TAG:
	switch ( node_tag(c2) )
	{
	case FAPP_TAG:
	case SUSPEND_TAG:
	    CHECK_STACK1();
	    sp	 -= 1;
	    sp[0] = c2;
	    sp[1] = (Node *)___38__1;
	    sp[2] = c1;
	    GOTO(c2->info->eval);
	case QUEUEME_TAG:
	case VARIABLE_TAG:
	    CHECK_STACK1();
	    sp	 -= 1;
	    sp[0] = c1;
	    sp[1] = (Node *)___38__1;
	    sp[2] = c2;
	    GOTO(c1->info->eval);
	case SUCCESS_TAG:
	    *++sp = c1;
	    GOTO(c1->info->eval);
	}
	break;
    case VARIABLE_TAG:
	/* evaluate the other argument then delay */
	switch ( node_tag(c2) )
	{
	case FAPP_TAG:
	case SUSPEND_TAG:
	case QUEUEME_TAG:
	    CHECK_STACK1();
	    sp	 -= 1;
	    sp[0] = c2;
	    sp[1] = (Node *)___38__1;
	    sp[2] = c1;
	    GOTO(c2->info->eval);
	case VARIABLE_TAG:
	    sp[0] = c1;
	    sp[1] = c2;
	    GOTO(delay_thread(___38__2, c1));
	case SUCCESS_TAG:
	    sp += 2;
	    RETURN(c1);
	}
	break;
    case SUCCESS_TAG:
	/* trivial case */
	switch ( node_tag(c2) )
	{
	case FAPP_TAG:
	case SUSPEND_TAG:
	case QUEUEME_TAG:
	    *++sp = c2;
	    GOTO(c2->info->eval);
	case VARIABLE_TAG:
	case SUCCESS_TAG:
	    sp += 2;
	    RETURN(c2);
	}
	break;
    }
    invalid_arg("(&)", node_tag(c1));
}

@
When an argument has been evaluated to head normal form, it must be
either a variable or the constant [[Success]]. In the latter case we
can simply return the other argument to the caller -- except if it is
still a queue-me closure. In the former case, we may return the
variable if the other argument was evaluated to [[Success]] in the
meantime.

<<constraints.c>>=
static
FUNCTION(___38__1)
{
    Node *c1, *c2;

 ENTRY_LABEL(___38__1)
    /* if the evaluated argument is now success return the other one */
    for ( c1 = sp[0]; node_tag(c1) == INDIR_TAG; c1 = c1->n.node )
	;
    c2 = sp[1];
    if ( node_tag(c1) == SUCCESS_TAG )
    {
    again_1:
        switch ( node_tag(c2) )
        {
	case INDIR_TAG:
	    c2 = c2->n.node;
	    goto again_1;
	case QUEUEME_TAG:
	    *++sp = c2;
	    GOTO(c2->info->eval);
	case VARIABLE_TAG:
	case SUCCESS_TAG:
	    sp += 2;
	    RETURN(c2);
	default:
	    invalid_arg("(&)", node_tag(c2));
	}
    }

    /* wait for the other argument being evaluated if it is a queue-me */
    ASSERT(node_tag(c1) == VARIABLE_TAG);
 again_2:
    switch ( node_tag(c2) )
    {
    case INDIR_TAG:
	c2 = c2->n.node;
	goto again_2;
    case QUEUEME_TAG:
	CHECK_STACK1();
	sp   -= 1;
	sp[0] = c2;
	sp[1] = (Node *)___38__1;
	sp[2] = c1;
	GOTO(c2->info->eval);
    case VARIABLE_TAG:
	sp[0] = c1;
	sp[1] = c2;
	GOTO(delay_thread(___38__2, c1));
    case SUCCESS_TAG:
        break;
    }

    sp += 2;
    RETURN(c1);
}

@
After waiting for an unbound variable to become ground, we can always
return the other argument. Note that this code can be invoked only if
the other argument was a variable node. Therefore, it can only be
still a variable or an indirection, which either points to another
variable or to [[Success]].

<<constraints.c>>=
static
FUNCTION(___38__2)
{
    Node *c1, *c2;

 ENTRY_LABEL(___38__2)
    for ( c1 = sp[0]; node_tag(c1) == INDIR_TAG; c1 = c1->n.node )
	;
    for ( c2 = sp[1]; node_tag(c2) == INDIR_TAG; c2 = c2->n.node )
	;
    ASSERT(node_tag(c1) == SUCCESS_TAG);
    ASSERT(node_tag(c2) == SUCCESS_TAG || node_tag(c2) == VARIABLE_TAG);

    sp += 2;
    RETURN(c2);
}

@ 
The unsafe function [[spawnConstraint]] forks a new concurrent
computation, but does not wait for its termination. It is defined for
compatibility with PAKCS.

<<constraints.c>>=
DECLARE_ENTRYPOINT(__spawnConstraint);
DECLARE_LABEL(__spawnConstraint_1);

FUNCTION(__spawnConstraint)
{
    Node *c;

    EXPORT_LABEL(__spawnConstraint)
 ENTRY_LABEL(__spawnConstraint)
    c = sp[0];
    for (;;)
    {
	switch ( node_tag(c) )
	{
	case INDIR_TAG:
	    c = c->n.node;
	    continue;

	case FAPP_TAG:
	case SUSPEND_TAG:
	    CHECK_STACK(2);
	    sp	 -= 1;
	    sp[0] = c;
	    sp[1] = (Node *)__spawnConstraint_1;
	    start_thread(2);
	    GOTO(sp[0]->info->eval);

	case QUEUEME_TAG:
	case VARIABLE_TAG:
	case SUCCESS_TAG:
	    break;
	}
	break;
    }

    sp += 1;
    GOTO(__spawnConstraint_1);
}

static
FUNCTION(__spawnConstraint_1)
{
    Node *r;
 ENTRY_LABEL(__spawnConstraint_1)
    r = sp[0];
    if ( is_boxed(r) )
	GOTO(r->info->eval);
    sp += 1;
    RETURN(r);
}
