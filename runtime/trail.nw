% -*- noweb-code-mode: c-mode -*-
% $Id: trail.nw 1744 2005-08-23 16:17:12Z wlux $
%
% Copyright (c) 2002-2005, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{The trail}
The trail is used to record all destructive updates that must be
undone when backtracking to a choicepoint or leaving a search
space. Updates apply to updatable nodes, i.e. variables, queue-me
closures and suspensions, but also array elements and thread-queue
entries can be changed. Some of these updates only change one field of
a node, while other also change the node type by overwriting the
info-pointer. For simplicity we always save the info pointer on the
trail. Other possible options could be to use the least significant
bit of the address to distinguish between one word and two word
updates, store both updates separately, or to use two different trail
stacks.

<<trail.h>>=
typedef struct save_rec {
    word	 *addr;		/* address of updated node */
    word	 info;		/* old info vector */
    unsigned int ofs;		/* offset within node */
    word	 val;		/* saved value */
} SaveRec;

@
The trail is implemented as a single array starting at the address
[[trail_base]] and ending at [[trail_end]]. The register [[tp]]
serves as an allocation pointer for the trail. Before adding a new
entry to the trail it must checked that there is no trail
overflow. This can be done with the [[CHECK_TRAIL]] or
[[CHECK_TRAIL1]] macro.

<<trail.h>>=
extern SaveRec *trail_base, *trail_end;
extern SaveRec *tp;

extern void trail_overflow(void) __attribute__ ((noreturn));

#define CHECK_TRAIL1()	if ( tp == trail_end ) trail_overflow();
#define CHECK_TRAIL(n)	if ( tp + n > trail_end ) trail_overflow();

@
<<trail.c>>=
#include "config.h"
#include <stdio.h>
#include <stdlib.h>
#include "debug.h"
#include "run.h"
#include "heap.h"
#include "trail.h"
#include "main.h"

SaveRec *tp;
SaveRec *trail_base;
SaveRec *trail_end;

void
trail_overflow()
{
    fprintf(stderr,
	    "Trail overflow; current size: %u bytes\n"
	    "USE +RTS -tSIZE to increase trail size\n",
	    trailsize);
    exit(2);
}

@
The initialization function allocates a trail array with the specified
size and initializes the trail pointer.

<<trail.h>>=
extern void init_trail(unsigned int trail_size);

@
<<trail.c>>=
void
init_trail(unsigned int trail_size)
{
    trail_size = (trail_size + pagemask) & ~pagemask;
    trail_base = (SaveRec *)malloc(trail_size + pagemask);
    if ( trail_base == 0 )
	sys_error("init_trail");

    trail_base = (SaveRec *)(((long)trail_base + pagemask) & ~pagemask);
    trail_end = trail_base + trail_size / sizeof(SaveRec);
    tp	      = trail_base;
}

@
When an updatable node is changed, the info-pointer and the changed
field of the node have to be saved on the trail if the overwritten
state of the node may be restored later. This is the case for all
nodes which are not allocated in the current heap segment, i.e. before
the current choicepoint or search context was pushed onto the
stack. In addition, for fields that can be updated more than, like the
wait-queue of a variable node, the old state need to be saved only
once for each heap segment. As the compiler uses fresh values to
overwrite the node in this case, we need not scan the trail to detect
such multiple changes of the same field. Instead we can check the
contents field that is going to be saved. If its current value points
to a node in the current heap segment while the node itself is in
another segment, the node has been overwritten and saved
already. Thus, it is not necessary to save it again. The [[SAVE]]
macro checks for both conditions and saves the info pointer and old
value only when necessary. In contrast, the [[DO_SAVE]] macro always
saves its argument to the trail.

<<trail.h>>=
#define INFO_OFS	word_offsetof(Node, info)

#define DO_SAVE(v,f) do { \
    CHECK_TRAIL1(); \
    tp->addr = (word *)(v); \
    tp->info = tp->addr[INFO_OFS]; \
    tp->ofs  = (word *)&(v->f) - (word *)(v); \
    tp->val  = (word)(v->f); \
    tp++; \
} while (0)
#define SAVE(v,f) do { \
    if ( (word *)(v) < hlim && (word *)(v->f) < hlim ) \
	DO_SAVE(v,f); \
} while (0)

@
Upon backtracking, the values saved in the trail have to be
restored. This can be done by decrementing the trail pointer and
restoring the saved value from the trail entry until the old value of
the trail pointer is reached. The [[RESTORE]] macro performs this
task.

<<trail.h>>=
#define RESTORE(oldTp) do { \
    while ( tp > oldTp ) { \
	--tp; \
	tp->addr[INFO_OFS] = tp->info; \
	tp->addr[tp->ofs]  = tp->val; \
    } \
} while (0)
