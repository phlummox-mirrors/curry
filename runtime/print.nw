% -*- noweb-code-mode: c-mode -*-
% $Id: print.nw 1856 2006-02-19 10:36:44Z wlux $
%
% Copyright (c) 2001-2005, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{Printing the Result}
When the computation is finished, the computed result and the bindings of
all global variables can be printed with the function [[print_result]].

<<print.h>>=
extern void print_result(const char *var_names[], Node *vars[], Node *result);

@ 
<<print.c>>=
#include "config.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "debug.h"
#include "run.h"
#include "heap.h"
#include "trail.h"
#include "data.h"
#include "disequal.h"
#include "vars.h"
#include "cstring.h"
#include "print.h"

static void    print_node(unsigned, Node *);
static void    print_app(unsigned, Node *, unsigned, Node **);
static boolean is_string(Node *);
static void    print_string(Node *);
static void    print_list(Node *);
static void    print_tuple(Node *);
static boolean print_constraints(boolean, Node *);
static boolean print_app_constraints(boolean, unsigned, Node **);
static boolean print_constrained_var(boolean, Node *);

@ 
The function [[print_result]] prints the computed result and the
bindings of the global variables. Only those variables which have been
bound by the program are actually printed. In order to assign names to
the unbound variables, a dictionary is used (see below). This
dictionary is initialized before printing the nodes and reset
afterwards.

Note that it is safe to enter the names of the goal's free variables
into the dictionary because these entries are never going to be
released. This is prevented by keeping a pointer to the initial
closure at the bottom of the stack. This closure is used to access the
bindings of the free variables when the computation succeeds.                %'

<<print.c>>=
void
print_result(const char **var_names, Node **vars, Node *result)
{
    unsigned	     i, n;
    boolean	     hasAnswer;
    struct dict_node *tail;

    tail      = names_tail;
    hasAnswer = false;
    for ( n = 0; var_names[n]; n++ )
	if ( !is_variable_node(vars[n]) )
	{
	    if ( !hasAnswer )
	    {
		printf("{%s = ", var_names[n]);
		hasAnswer = true;
	    }
	    else
		printf(", %s = ", var_names[n]);
	    print_node(0, vars[n]);
	}

    hasAnswer = print_constraints(hasAnswer, result);
    for ( i = 0; i < n; i++ )
	hasAnswer = print_constraints(hasAnswer, vars[i]);

    if ( hasAnswer )
	printf("} ");

    print_node(0, result);
    release_names(tail);
}

@
In general, when a node is printed we will use the closure name
found in the info vector of the node. However, some kinds of nodes are
handled differently. In particular, for each unbound variable a name
is generated and this name is shown by the printer. Special functions
are used for printing lists and tuples. The [[prec]] parameter is used
to determine when to enclose a term in parentheses. At present, we
distinguish three different levels: [[0]] is used for terms at the
top-level and arguments of a list or tuple, [[1]] is used for
arguments within an infix application, and [[2]] is used for arguments
in a regular application.

<<print.c>>=
static void
print_node(unsigned prec, Node *node)
{
    char	 buf[32];
    unsigned int argc;
    double	 d;
    const char	 *name;

    for (;;)
    {
#if !ONLY_BOXED_OBJECTS
	if ( is_unboxed(node) )
	    printf(prec > 0 && unboxed_val(node) < 0 ? "(%ld)" : "%ld",
		   unboxed_val(node));
	else
#endif
	    switch ( node_tag(node) )
	    {
	    case CHAR_TAG:
		printf("'%s'", lit_char(buf, node->ch.ch, '\''));
		break;
	    case INT_TAG:
		printf(prec > 0 && node->i.i < 0 ? "(%ld)" : "%ld",
		       node->i.i);
		break;
	    case FLOAT_TAG:
		get_double_val(d, node->f);
		lit_double(buf, d);
		printf(prec > 0 && buf[0] == '-' ? "(%s)" : "%s", buf);
		break;
	    case PTR_TAG:
		printf(prec > 1 ? "(%s %p)" : "%s %p",
		       node->info->cname, node->p.ptr);
		break;
	    case FOREIGN_PTR_TAG:
		printf(prec > 1 ? "(%s %p)" : "%s %p",
		       node->info->cname, node->fp.ptr);
		break;
	    case VARIABLE_TAG:
		printf("%s", lookup_name(node));
		break;
	    case PAPP_TAG:
	    case FAPP_TAG:
		print_app(prec, node, closure_argc(node), node->c.args);
		break;
	    case SUSPEND_TAG:
		argc = suspend_argc(node);
		if ( argc == 1 && node->s.args[0] == 0 )
		    argc = 0;
		print_app(prec, node, argc, node->s.args);
		break;
	    case QUEUEME_TAG:
		printf("Suspended");
		break;
	    case INDIR_TAG:
		node = node->n.node;
		continue;
	    default:
		if ( is_abstract_node(node) || is_search_cont_node(node) )
		{
		    name = node->info->cname;
		    if ( name == 0 )
			name = "<abstract>";
		    printf("%s", name);
		}
		else if ( node->info == (NodeInfo *)&cons_info )
		{
		    if ( is_string(node) )
			print_string(node);
		    else
			print_list(node);
		}
		else if ( is_tuple(node->info) )
		    print_tuple(node);
		else if ( is_vector(node) )
		    print_app(prec, node, vector_argc(node), node->a.args);
		else
		    print_app(prec, node, closure_argc(node), node->c.args);
		break;
	    }
	break;
    }
}

static void
print_app(unsigned prec, Node *node, unsigned argc, Node **argv)
{
    unsigned i;
    boolean  isop   = is_operator(node->info) && !is_tuple(node->info);
    boolean  infix  = isop && argc == 2;
    boolean  parens = infix ? prec > 0 : prec > 1 && argc != 0;

    if ( parens )
	putchar('(');

    if ( infix )
    {
	print_node(1, argv[0]);
	printf(" %s ", node->info->cname);
	print_node(1, argv[1]);
    }
    else
    {
	printf(isop ? "(%s)" : "%s", node->info->cname);

	for ( i = 0; i < argc ; i++ )
	{
	    putchar(' ');
	    print_node(2, argv[i]);
	}
    }

    if ( parens )
	putchar(')');
}

@
The list printer shows lists in Curry's usual list notation. If
the tail of the list is not an empty list, it will be printed in
Prolog style, i.e., the tail is separated from the rest of the list by
a vertical bar instead of a comma.                                           %'

If the list is ground and consists of only characters, it is displayed
as a string. Note that we need to traverse the whole list in order to
check this property. Fortunately, we know that the printing code is
applied to finite data terms only.

<<print.c>>=
static boolean
is_string(Node *list)
{
    Node *head;

    while ( list->info == &cons_info )
    {
	head = list->c.args[0];
	while ( is_boxed(head) && head->info->tag == INDIR_TAG )
	    head = head->n.node;
	if ( is_unboxed(head) || head->info->tag != CHAR_TAG )
	    return false;

	list = list->c.args[1];
	while ( list->info->tag == INDIR_TAG )
	    list = list->n.node;
    }
    
    return list == nil;
}

static void
print_string(Node *list)
{
    char buf[8];
    Node *head;

    putchar('"');
    while ( list->info == &cons_info )
    {
	head = list->c.args[0];
	while ( is_boxed(head) && head->info->tag == INDIR_TAG )
	    head = head->n.node;
	ASSERT(is_boxed(head) && head->info->tag == CHAR_TAG);
	printf("%s", lit_char(buf, head->ch.ch, '"'));

	list = list->c.args[1];
	while ( list->info->tag == INDIR_TAG )
	    list = list->n.node;
   }
   ASSERT(list == nil);
   putchar('"');
}

static void
print_list(Node *list)
{
    char sep = '[';

    while ( list->info == &cons_info )
    {
	putchar(sep);
	print_node(0, list->c.args[0]);
	sep = ',';

	list = list->c.args[1];
	while ( list->info->tag == INDIR_TAG )
	    list = list->n.node;
    }

    if ( list != nil )
    {
	putchar('|');
	print_node(0, list);
    }

    putchar(']');
}

static void
print_tuple(Node *node)
{
    unsigned int i, argc;
    boolean	 first = true;
    Node	 **argv;

    putchar('(');

    if ( is_vector(node) )
    {
	argc = vector_argc(node);
	argv = node->a.args;
    }
    else
    {
	argc = closure_argc(node);
	argv = node->c.args;
    }
    for ( i = 0; i < argc; i++ )
    {
	if ( first )
	    first = false;
	else
	    printf(",");
	print_node(0, argv[i]);
    }

    putchar(')');
}

@
The printer traverses the result and all free variables and outputs
all constraints it encounters. In order to print the constraints for a
variable only once, the constraint field of the variable node is reset
before the constraint is printed. The constraint itself is saved on
the trail so that it is restored when the runtime system backtracks to
compute the next solution.

<<print.c>>=
static boolean
print_constraints(boolean hasAnswer, Node *node)
{
    unsigned int argc;

    for (;;)
    {
	if ( is_boxed(node) )
	    switch ( node_tag(node) )
	    {
	    case PAPP_TAG:
	    case FAPP_TAG:
		hasAnswer = print_app_constraints(hasAnswer,
						  closure_argc(node),
						  node->c.args);
		break;
	    case VARIABLE_TAG:
		if ( node->v.cstrs )
		    hasAnswer = print_constrained_var(hasAnswer, node);
		break;
	    case SUSPEND_TAG:
		argc = suspend_argc(node);
		if ( argc > 1 || node->s.args[0] )
		    hasAnswer = print_app_constraints(hasAnswer,
						      argc,
						      node->s.args);
		break;
	    case INDIR_TAG:
		node = node->n.node;
		continue;
	    default:
		if ( is_capp_node(node) )
		{
		    if ( is_vector(node) )
			hasAnswer = print_app_constraints(hasAnswer,
							  vector_argc(node),
							  node->a.args);
		    else
			hasAnswer = print_app_constraints(hasAnswer,
							  closure_argc(node),
							  node->c.args);
		}
		break;
	    }
	break;
    }
    return hasAnswer;
}

static boolean
print_app_constraints(boolean hasAnswer, unsigned argc, Node **argv)
{
    unsigned i;

    for ( i = 0; i < argc; i++ )
	hasAnswer = print_constraints(hasAnswer, argv[i]);

    return hasAnswer;
}

static boolean
print_constrained_var(boolean hasAnswer, Node *var)
{
    Constraint *cstrs;

    ASSERT(is_variable_node(var) && var->v.cstrs != 0);

    cstrs = var->v.cstrs;
    SAVE(var, v.cstrs);
    var->v.cstrs = 0;

    for ( ; cstrs; cstrs = cstrs->cstrs )
    {
	if ( !hasAnswer )
	{
	    printf("{");
	    hasAnswer = true;
	}
	else
	    printf(", ");
	print_node(0, var);
	printf(" /= ");
	print_node(0, ((Disequality *)cstrs)->node);

	hasAnswer = print_constraints(hasAnswer, ((Disequality *)cstrs)->node);
    }

    return hasAnswer;
}
