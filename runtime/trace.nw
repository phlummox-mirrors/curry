% -*- noweb-code-mode: c-mode -*-
% $Id: trace.nw 1744 2005-08-23 16:17:12Z wlux $
%
% Copyright (c) 2001-2005, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{Tracing}
The abstract machine provides a simple tracing facility. This is
implemented by the [[trace]] function which will print its arguments
to the standard error output. Like the [[printf]] function, the
[[trace]] function uses a format string to specify its output. The
following formatting directives are supported:
\begin{itemize}
\item [[%c]] displays the next argument a single character
\item [[%d]] displays the next argument as a signed decimal number
\item [[%g]] displays the next argument as a floating point number
\item [[%u]] displays the next argument as an unsigned decimal number
\item [[%s]] displays the next argument as a string
\item [[%x]] displays the next argument as an unsigned hexadecimal number
\item [[%A]] displays the address of the node found as next argument
\item [[%I]] displays the current thread id and indents the rest of
  the line according to the nesting depth of the current thread
\item [[%N]] displays the node found as next argument
\item [[%V]] the next argument is a counter and the second argument a
  pointer to an array of nodes. Each node is displayed preceded by a
  single blank
\end{itemize}

By using the [[TRACE]] macro, tracing can be enabled or disabled under
control of the global variable [[do_trace]].

\ToDo{The code for the \texttt{\%I} is not bulletproof. It assumes
that every address on the stack which is smaller than that of
[[environ]] is a return address. In addition, it assumes that all
return addresses on the stack are even.}

<<trace.h>>=
#define TRACE(x) do { if ( do_trace ) trace x; } while ( 0 )

extern int do_trace;
void trace(const char *fmt, ...);

@
<<trace.c>>=
#include "config.h"
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include "run.h"
#include "heap.h"
#include "stack.h"
#include "threads.h"
#include "eval.h"
#include "cstring.h"
#include "trace.h"

#if 0
/* This variable must be defined by the main program */
int do_trace;
#endif

static void trace_showaddr(Node *node);
static void trace_shownode(int depth, Node *node);
static void trace_showapp(int depth, Node *node, unsigned argc, Node **argv);

void
trace(const char *fmt, ...)
{
    va_list	 ap;
    const char	 *cp;
    Node	 **fp, **argv;
    int		 depth = do_trace - 1;
    unsigned int i, argc;
    extern char	 **environ;

    va_start(ap, fmt);
    for ( cp = fmt; *cp != '\0'; cp++ )
    {
	if ( *cp == '%' )
	    switch ( *++cp )
	    {
	    case 'c':
		fprintf(stderr, "%c", va_arg(ap, int));
	        break;
	    case 'd':
	        fprintf(stderr, "%d", va_arg(ap, int));
	        break;
	    case 'g':
	        fprintf(stderr, "%g", va_arg(ap, double));
	        break;
	    case 's':
		fprintf(stderr, "%s", va_arg(ap, const char *));
		break;
	    case 'u':
		fprintf(stderr, "%u", va_arg(ap, unsigned int));
		break;
	    case 'x':
		fprintf(stderr, "%x", va_arg(ap, unsigned int));
		break;
	    case 'A':
		trace_showaddr(va_arg(ap, Node *));
		break;
	    case 'I':
		fprintf(stderr, "[%u]", cid);
		for ( fp = sp; fp < ds_base; fp++ )
		    if ( *fp && is_boxed(*fp)
			 && (char *)*fp < (char *)&environ
			 && (Label)*fp != update )
			fputc(' ', stderr);
		break;
	    case 'N':
	        trace_shownode(depth, va_arg(ap, Node *));
		break;
	    case 'V':
	    	argc = va_arg(ap, unsigned int);
	        argv = va_arg(ap, Node **);
	        for ( i = 0; i < argc; i++ )
		{
		    fputc(' ', stderr);
	    	    trace_shownode(depth, argv[i]);
		}
		break;
	    default:
		fputc(*cp, stderr);
		break;
	    }
	else
	    fputc(*cp, stderr);
    }
    va_end(ap);
}

static void
trace_showaddr(Node *node)
{
    if ( node == 0 )
	fprintf(stderr, "-null-");
#if !ONLY_BOXED_OBJECTS
    else if ( is_unboxed(node) )
	fprintf(stderr, "-unboxed%ld-", unboxed_val(node));
#endif
    else if ( heap_base <= (word *)node && (word *)node <= heap_end )
	fprintf(stderr, "-node%lu-", (long)(node - (Node *)heap_base));
    else
	fprintf(stderr, "%p", node);
}

static void
trace_shownode(int depth, Node *node)
{
    char	 buf[32];
    unsigned int argc;
    double	 d;
    const char	 *name;

    if ( node == 0 )
	fprintf(stderr, "-null-");
#if !ONLY_BOXED_OBJECTS
    else if ( is_unboxed(node) )
	fprintf(stderr, "%ld", unboxed_val(node));
#endif
    else
	switch ( node_tag(node) )
	{
	case CHAR_TAG:
	    fprintf(stderr, "'%s'", lit_char(buf, node->ch.ch, '\''));
	    break;
	case INT_TAG:
	    fprintf(stderr, "%ld", node->i.i);
	    break;
	case FLOAT_TAG:
	    get_double_val(d, node->f);
	    fprintf(stderr, "%s", lit_double(buf, d));
	    break;
	case PTR_TAG:
	    fprintf(stderr, depth > 0 ? "(%s %p)" : "(%s ...)",
		    node->info->cname, node->p.ptr);
	    break;
	case FOREIGN_PTR_TAG:
	    fprintf(stderr, depth > 0 ? "(%s %p)" : "(%s ...)",
		    node->info->cname, node->fp.ptr);
	    break;
	case VARIABLE_TAG:
	    fprintf(stderr, "var@%p", node);
	    break;
	case QUEUEME_TAG:
	    fprintf(stderr, "que@%p", node);
	    break;
	case SUSPEND_TAG:
	    fprintf(stderr, "susp@%p=", node);
	    argc = suspend_argc(node);
	    if ( argc == 1 && node->s.args[0] == 0 )
		argc = 0;
	    trace_showapp(depth, node, argc, node->s.args);
	    break;
	case SEARCH_CONT_TAG:
	    fprintf(stderr, "cont@%p", node);
	    break;
	case INDIR_TAG:
	    trace_shownode(depth, node->n.node);
	    break;
	default:
	    if ( is_abstract_node(node) )
	    {
		name = node->info->cname;
		if ( name == 0 )
		    name = "<abstract>";
		fprintf(stderr, "%s@%p", name, node);
	    }
	    else if ( is_vector(node) )
		trace_showapp(depth, node, vector_argc(node), node->a.args);
	    else
		trace_showapp(depth, node, closure_argc(node), node->c.args);
	    break;
	}
}

static void
trace_showapp(int depth, Node *node, unsigned argc, Node **argv)
{
    unsigned i;

    if ( argc > 0 )
	fputc('(', stderr);

    fprintf(stderr, "%s", node->info->cname);
    if ( depth > 0 )
	for ( i = 0; i < argc; i++ )
	{
	    fputc(' ', stderr);
	    trace_shownode(depth - 1, argv[i]);
	}
    else if ( argc > 0 )
	fprintf(stderr, " ...");

    if ( argc > 0 )
	fputc(')', stderr);
}
